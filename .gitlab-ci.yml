stages:
  - test
  - release

variables:
  GO_VERSION: "1.25.4"
  GOPATH: $CI_PROJECT_DIR/.go
  GOCACHE: $CI_PROJECT_DIR/.go-cache
  GOLANGCI_LINT_CACHE: $CI_PROJECT_DIR/.golangci-lint-cache

# Cache Go modules and build cache
.go-cache:
  cache:
    key:
      files:
        - go.sum
    paths:
      - .go/pkg/mod/
      - .go-cache/
    policy: pull-push

# =============================================================================
# TEST STAGE
# =============================================================================
test:
  stage: test
  image: golang:${GO_VERSION}
  tags:
    - fgs-dind-runner-vn
  extends: .go-cache
  variables:
    GOGC: "50"
    GOMEMLIMIT: "512MiB"
  script:
    - go mod download
    - go build ./...
    - go vet ./...
    - go test -coverprofile=coverage.out ./...
  interruptible: true
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.out
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

lint:
  stage: test
  image: golangci/golangci-lint:v2.7.0
  tags:
    - fgs-dind-runner-vn
  variables:
    GOGC: "20"
    GOMEMLIMIT: "512MiB"
    GOFLAGS: "-buildvcs=false"
  cache:
    key:
      files:
        - go.sum
    paths:
      - .go/pkg/mod/
      - .go-cache/
      - .golangci-lint-cache/
    policy: pull-push
  script:
    - go mod download
    - golangci-lint run --timeout 10m --concurrency 2
  interruptible: true
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# RELEASE STAGE - Auto version bump and tag
# =============================================================================
release:
  stage: release
  image: golang:${GO_VERSION}
  tags:
    - fgs-dind-runner-vn
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0  # Full clone for tag history
  before_script:
    - apt-get update && apt-get install -y git
    - git config user.email "ci@futuregamestudio.net"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - |
      # Get latest tag
      LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
      echo "Latest tag: $LATEST_TAG"
      
      # Parse version (remove 'v' prefix)
      VERSION=${LATEST_TAG#v}
      MAJOR=$(echo $VERSION | cut -d. -f1)
      MINOR=$(echo $VERSION | cut -d. -f2)
      PATCH=$(echo $VERSION | cut -d. -f3)
      
      # Check commit messages for version bump type
      # [major] or BREAKING CHANGE -> major bump
      # [minor] or feat: -> minor bump  
      # [patch] or fix: or default -> patch bump
      COMMIT_MSG=$(git log -1 --pretty=%B)
      
      if echo "$COMMIT_MSG" | grep -qiE '\[major\]|BREAKING CHANGE'; then
        MAJOR=$((MAJOR + 1))
        MINOR=0
        PATCH=0
        echo "Major version bump detected"
      elif echo "$COMMIT_MSG" | grep -qiE '\[minor\]|^feat(\(.+\))?:'; then
        MINOR=$((MINOR + 1))
        PATCH=0
        echo "Minor version bump detected"
      else
        PATCH=$((PATCH + 1))
        echo "Patch version bump (default)"
      fi
      
      # Find next available tag (auto-increment if tag exists)
      while true; do
        NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
        if ! git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
          break
        fi
        echo "Tag $NEW_TAG already exists, incrementing patch..."
        PATCH=$((PATCH + 1))
      done
      
      echo "New version: $NEW_TAG"
      
      # Create and push tag
      git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
      git push origin "$NEW_TAG"
      
      echo "âœ… Released $NEW_TAG"
  interruptible: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
  needs:
    - test

